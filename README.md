
# Gait Animator
Gait animator is an [Unreal Engine 4][4] powered 3D human activity renderer, firstly created in Aoyagi's Lab at [Tokyo Institute of Technology][3]. It makes use of skeletal mesh animation and direct bone controls to render on screen activity information streamed through a local socket.

The application has been designed to accept a stream of [JSON][2] serialized data, containing relative Euler angles for each joint of the skeleton that should be controlled.

## Setup
Gait Animator requires a number of things to run:

 - Unreal Engine 4
 - [Visual Studio 2013 Community Edition][5] [I am sorry I did not manage to test it under Linux/MacOSX]
 - [GitHub for Windows][6] (or any other git client for windows)

After installing the three applications open Unreal Engine 4 editor and start a new __C++ Third-Person__ project, in order to have an empty skeleton to work on. After the project has been generated by the engine clone this project inside the Project Folder.

The project should already have all the required elements and can be started by opening the Visual Studio solution, selecting __Debug Editor__ as build configuration and the correct platform (e.g. __Win64__ on 64bit Windows). This should open the Unreal Editor with the correct project already loaded.

## How to use it

The project is already configured to accept a number of bones and control them using BluePrint animations. The application does not expect to synchronise with the server. The application does not expect to synchronise with the server. Even though this is not a good approach I tested with a `30 fps` data feed and there were no de-synchronisations. It might be useful to add a way to control the frequency of data feeding in the server application, as it was done in the [testing server][7].

### JSON Euler triplet data

In order to control joints it is required to generate a JSON serialised data packet containing a triplet of Euler angles for each joint. The serialised data is structured in the following way:

    {
	    "joint": {
		    "pitch": pitch_angle_in_degrees,
		    "roll":  roll_angle_in_degrees,
		    "yaw":   yaw_angle_in_degrees
		},
		...
    }
The order of joints or angles inside each sub-structure does not change the final result, as the data is extracted in Unreal Engine using identifiers and not indices.

### Defined joints

The application is developed to accept a number of Euler triplets, but it is very rigid in its implementation. Future possible implementations will be more flexible in this sense. The accepted joints are:

 - `left_thigh` and `right_thigh` to control the hip joints
 - `left_calf` and `right_calf` to control the knee
 - `pelvis` to control the centre of the hips
 - `spine_01` and `spine_03` to control the lower and upper part of the spine
 - `left_upper_arm` and `right_upper_arm` to control the shoulder joint
 - `left_lower_arm` and `right_lower_arm` to control the elbow 

### Rotations

Unreal Engine 4 allows the control of skeletal bones' rotations through modifications of their local rotations. This means that the rotation of the parent bones are transmitted to their children.

Unreal Engine 4 defines rotations as follows:

 - Rotation on the `X` axis -> `Roll`
 - Rotation on the `Y` axis -> `Pitch`
 - Rotation on the `Z` axis -> `Yaw`

These definitions are true in Unreal Engine's 3D space, as the `Z` axis goes UP (i.e. the ground's normal vector), while `X` and `Y` axes form a plane parallel to the ground.

### C++ and BluePrint implementation notes

The application has been written using both C++11 and BluePrint, the graphical programming language used in Unreal Engine 4. There are three main highlights in order to understand how to change the way the application behaves.

The first is in the file `NetworkBlueprintLibrary.cpp`, which provides global functions accessible from BluePrint and controls socket communications and JSON data de-serialisation. The function `GetRotationPacket()` gets the next packet from the socket buffer and de-serialises data in an array of `FRotator`, Unreal Engine's data structure to represent rotations in Euler angles. However, due to implementation, the indices of each joint are fixed by how they are extracted from the dataset. The `NetworkSetup(int32 ServerPort)` presents one important detail, which is the IP address of the server. If the server is not on the same machine of the Animator, then it is necessary to change the following line:

    FIPv4Address ServerAddress = FIPv4Address(127, 0, 0, 1);
Or make the function accept a `TArray<int>` that contains the four IP values.

`BPGaitDoll`, contained in `Content\ThirdPerson\Character`, is the animation BluePrint that controls the Skeleton, getting the `FRotators` and applying them to the different joints.

![BPGaitDoll AnimGraph](https://raw.githubusercontent.com/Jazzinghen/GaitAnimator/master/Documentation/BPGaitDollAnimGraph.png) 

![BPGaitDoll EventGraph](https://raw.githubusercontent.com/Jazzinghen/GaitAnimator/master/Documentation/BPGaitDollEventGraph.png)

Animation BluePrints are divided in Animation Graphs and Event Graphs, as shown in the previous pictures. Animation Graph is run every time the animation should be updated (e.g. every frame), while the Event Graph defines actions that should be ran every time an event fires.

As it is not possible to update the skeleton using the Event Graph and it is not possible to run BluePrint functions and branches in the Animation Graph, Gait Animator combines the two in order to extract data from the `FRotator` array by being sure all the informations are present. The operation is pretty straightforward: for each joint to control its respective function is executed and the returned `FRotator` is placed inside a variable that will be read by the Animation Graph.

There are various BluePrint functions, one for each joint, based on the current implementation, as can be seen in the Event Graph picture, however there is an additional generic function, called `GetData`, which accepts an input index. This should make changing the code easier.

The last part is the `GaitDollControlBP`, which is the BluePrint that initialise and regulates network communications.

![GaitDollControlBP BluePrint](https://raw.githubusercontent.com/Jazzinghen/GaitAnimator/master/Documentation/GaitDollControlBP.png)

The most interesting detail in this BluePrint is the `ServerPort` variable, which can be set to whichever is the one used by the server communicating to the application.

###Default configuration

The application is configured to connect to a server located on `localhost` on port `15300`. The application runs a single connection and then uses that socket to communicate as client (i.e. the application `connects` to the server).


> Written with [StackEdit][1].

[1]: https://stackedit.io/  "StackEdit"
[2]: http://json.org/ "JSON"
[3]: http://www.titech.ac.jp/ "TokyoTech"
[4]: https://www.unrealengine.com/ "Unreal Engine 4"
[5]: https://www.visualstudio.com/ "Microsoft Visual Studio"
[6]: https://windows.github.com/ "GitHub for Windows"
[7]: https://github.com/Jazzinghen/RubyGaitServer "Ruby Gait Server"